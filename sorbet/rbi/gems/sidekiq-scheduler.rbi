# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strong
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/sidekiq-scheduler/all/sidekiq-scheduler.rbi
#
# sidekiq-scheduler-3.0.0
module SidekiqScheduler
end
module SidekiqScheduler::Utils
  def self.enqueue_with_active_job(config); end
  def self.enqueue_with_sidekiq(config); end
  def self.initialize_active_job(klass, args); end
  def self.new_rufus_scheduler(options = nil); end
  def self.sanitize_job_config(config); end
  def self.stringify_keys(object); end
  def self.symbolize_keys(object); end
  def self.try_to_constantize(klass); end
  def self.update_job_last_time(name, last_time); end
  def self.update_job_next_time(name, next_time); end
end
module SidekiqScheduler::RedisManager
  def self.add_schedule_change(name); end
  def self.clean_schedules_changed; end
  def self.get_all_schedules; end
  def self.get_job_last_time(name); end
  def self.get_job_next_time(name); end
  def self.get_job_schedule(name); end
  def self.get_job_state(name); end
  def self.get_schedule_changes(from, to); end
  def self.hdel(hash_key, field_key); end
  def self.hget(hash_key, field_key); end
  def self.hset(hash_key, field_key, value); end
  def self.last_times_key; end
  def self.next_times_key; end
  def self.pushed_job_key(job_name); end
  def self.register_job_instance(job_name, time); end
  def self.remove_elder_job_instances(job_name); end
  def self.remove_job_next_time(name); end
  def self.remove_job_schedule(name); end
  def self.schedule_exist?; end
  def self.schedules_state_key; end
  def self.set_job_last_time(name, last_time); end
  def self.set_job_next_time(name, next_time); end
  def self.set_job_schedule(name, config); end
  def self.set_job_state(name, state); end
end
module SidekiqScheduler::Schedule
  def get_all_schedules; end
  def get_schedule(name = nil); end
  def infer_queue(klass); end
  def prepare_schedule(schedule_hash); end
  def reload_schedule!; end
  def remove_schedule(name); end
  def schedule!; end
  def schedule; end
  def schedule=(schedule_hash); end
  def set_schedule(name, config); end
  def try_to_constantize(klass); end
end
class SidekiqScheduler::Manager
  def initialize(options); end
  def load_scheduler_options(options); end
  def reset; end
  def start; end
  def stop; end
  include Sidekiq::Util
end
class SidekiqScheduler::RufusUtils
  def self.normalize_schedule_options(options); end
end
class SidekiqScheduler::Scheduler
  def active_job_enqueue?(klass); end
  def arguments_with_metadata(args, metadata); end
  def clear_schedule!(stop_option = nil); end
  def dynamic; end
  def dynamic=(arg0); end
  def dynamic_every; end
  def dynamic_every=(arg0); end
  def enabled; end
  def enabled=(arg0); end
  def enabled_queue?(job_queue, queues); end
  def enqueue_job(job_config, time = nil); end
  def handle_errors; end
  def idempotent_job_enqueue(job_name, time, config); end
  def initialize(options = nil); end
  def job_enabled?(name); end
  def listened_queues_only; end
  def listened_queues_only=(arg0); end
  def load_schedule!; end
  def load_schedule_job(name, config); end
  def new_job(name, interval_type, config, schedule, options); end
  def prepare_arguments(config); end
  def print_schedule; end
  def rails_env_matches?(config); end
  def reload_schedule!; end
  def rufus_scheduler; end
  def rufus_scheduler_options; end
  def rufus_scheduler_options=(options); end
  def schedule_state(name); end
  def scheduled_jobs; end
  def self.instance; end
  def self.instance=(value); end
  def self.method_missing(method, *arguments, &block); end
  def set_schedule_state(name, state); end
  def sidekiq_queues; end
  def toggle_job_enabled(name); end
  def unschedule_job(name); end
  def update_schedule; end
  extend Sidekiq::Util
end
class Rufus::Scheduler::Job
  def params; end
end
module Sidekiq
  extend SidekiqScheduler::Schedule
end
